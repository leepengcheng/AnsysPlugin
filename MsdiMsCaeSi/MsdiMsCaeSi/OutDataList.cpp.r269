#include "MsdiMsCaeSipch.h"

WString O_CaseName = L"";//工况名称
WString O_tableTitle= L"";//表头名称
double  O_titleFont = 3.5;//表头字体大小
double  O_contentFont = 2.6;//工况字体大小
double  O_heightCoe = 0.255;//高度比例
int O_XSpaceCnt = 6;//X坐标划分个数
int O_YSpaceCnt = 16;//Y坐标划分个数
double O_coorFont = 2.0;//坐标数字字体大小
int O_XValueCnt = 10;//X方向数值个数
int O_YValueCnt = 15;//Y方向数值个数
double O_valueFont=1.0;//数值字体大小
int O_decimal = 2;//数值字体大小
bvector<int>  outValueTypeint;
bvector<WString> outValueTypeWString;
DgnModelRefP OutDataModelRef = ACTIVEMODEL;
double move_dis;
extern void InitOutValueType(bvector<WString>& outValueTypeWString)
{
	bvector<WString>().swap(outValueTypeWString);
	outValueTypeWString.push_back(L"");

	//X向正应力
	outValueTypeWString.push_back(L"SX");
	//Y向正应力
	outValueTypeWString.push_back(L"SY");
	//Z向正应力
	outValueTypeWString.push_back(L"SZ");
	//次主应力
	outValueTypeWString.push_back(L"S1");
	//XY向剪应力
	outValueTypeWString.push_back(L"SXY");
	//YZ向剪应力
	outValueTypeWString.push_back(L"SYZ");
	//XZ向剪应力
	outValueTypeWString.push_back(L"SXZ");
	//X向位移
	outValueTypeWString.push_back(L"UX");
	//Y向位移
	outValueTypeWString.push_back(L"UY");
	//Z向位移
	outValueTypeWString.push_back(L"UZ");
}
void GetMeshMinMaxPoints(bvector<DPoint3d>& meshminpoints, bvector<DPoint3d>& meshmaxpoints,
	DPoint3d& minpoint, DPoint3d& maxpoint,int& projectID)
{
	NamedGroupCollectionPtr ngcCutFace;
	NamedGroupFlags ngfCutFace;
	NamedGroupPtr ngCutFace;
	ngcCutFace = NamedGroupCollection::Create(*ACTIVEMODEL);

	for each (NamedGroupPtr namedGroup in *ngcCutFace)
	{
		if (namedGroup.IsValid())
		{
			WString ngName = namedGroup->GetName();
			if (ngName.find(L"CAECLIP") != WString::npos)
			{
				splitNgName_Clip(ngName, UNUSE_WSTRING, projectID, UNUSE_INT, UNUSE_WSTRING,UNUSE_WSTRING);
				UInt32 graphicMembers;
				namedGroup->GetMemberCount(&graphicMembers, NULL);
				for (UInt32 i = 0; i < graphicMembers; i++)
				{
					ElementId elemid = namedGroup->GetMember(i)->GetElementId();
					EditElementHandle eeh;
					if (SUCCESS == eeh.FindByID(elemid, ACTIVEMODEL))//得到的每一个mesh面
					{
						DPoint3d ptmin;
						DPoint3d ptmax;
						bvector<DPoint3d>				pXYZ;

						if (SUCCESS == mdlMesh_getPolyfaceArrays(eeh.GetElementDescrCP(), NULL, &pXYZ, NULL, NULL))
						{
							for (int j = 0; j < pXYZ.size(); j++)
							{
								DPoint3d tempPt = pXYZ.at(j);
								if (j == 0)
								{
									ptmin = tempPt;
									ptmax = tempPt;
								}
								else
								{
									if (ptmin.x > tempPt.x)
									{			  
										ptmin.x = tempPt.x;
									}			  
									if (ptmin.y > tempPt.y)
									{			  
										ptmin.y = tempPt.y;
									}			  
									if (ptmax.x < tempPt.x)
									{			  
										ptmax.x = tempPt.x;
									}			  
									if (ptmax.y < tempPt.y)
									{			  
										ptmax.y = tempPt.y;
									}
								}
							}
						}
						
						meshminpoints.push_back(ptmin);
						meshmaxpoints.push_back(ptmax);
						if (i == 0)
						{
							minpoint.x = ptmin.x;
							minpoint.y = ptmin.y;
							minpoint.z = (ptmin.z + ptmax.z) / 2;
							maxpoint.x = ptmax.x;
							maxpoint.y = ptmax.y;
							maxpoint.z = (ptmin.z + ptmax.z) / 2;
						}
						else
						{
							if (minpoint.x > ptmin.x)
							{
								minpoint.x = ptmin.x;
							}
							if (minpoint.y > ptmin.y)
							{
								minpoint.y = ptmin.y;
							}
							if (maxpoint.x < ptmax.x)
							{
								maxpoint.x = ptmax.x;
							}
							if (maxpoint.y < ptmax.y)
							{
								maxpoint.y = ptmax.y;
							}
						}
					}
				}

			}
		}
	}
}

//将需要输出的计算数值放到MAP中
void GetAllNineDatas(bmap<WString, bvector<double>>& allDatas, int caseID, int ProjecID)
{
	bool hux = 1; 
	bool huy = 1;
	bool huz = 1;
	bool hother = 1;
	Db m_db;
	Statement *m_statment;
	WString strSql;
	StatusInt rc;

	strSql.append(L"SELECT ");
	strSql.append(L"UX,UY,UZ,SX,SY,SZ,SXY,SXZ,SYZ");
	strSql.append(L" \n");
	strSql.append(L"FROM RESULTS \n");
	strSql.append(L"WHERE ProjectId = @ProjectId AND CaseId = @CaseId \n");
	strSql.append(L"ORDER BY ID \n");

	rc = OpenDB(m_db);
	if (rc == BE_SQLITE_OK)
	{
		m_statment = new Statement();

		size_t len = strSql.length() + 1;
		CharP cSQL = (CharP)malloc(len*sizeof(char));
		strSql.ConvertToLocaleChars(cSQL);

		rc = m_statment->Prepare(m_db, cSQL);

		m_statment->BindInt(1, ProjecID);
		m_statment->BindInt(2, caseID);

		if (rc == BE_SQLITE_OK)
		{
			while (m_statment->Step() == BE_SQLITE_ROW)
			{
				double ux, uy, uz, sx, sy, sz, sxy, sxz, syz;
				if (m_statment->IsColumnNull(0) != true && hux == 1)//UX
				{
					ux = m_statment->GetValueDouble(0);
					allDatas[L"UX"].push_back(ux);
				}
				else
				{
					hux = 0;
				}
				if (m_statment->IsColumnNull(1) != true && huy == 1)//UY
				{
					uy = m_statment->GetValueDouble(1);
					allDatas[L"UY"].push_back(uy);
				}
				else
				{
					huy = 0;
				}
				if (m_statment->IsColumnNull(2) != true && huz == 1)//UZ
				{
					uz = m_statment->GetValueDouble(2);
					allDatas[L"UZ"].push_back(uz);
				}
				else
				{
					huz = 0;
				}
				if (m_statment->IsColumnNull(3) != true && hother == 1)//SX
				{
					sx = m_statment->GetValueDouble(3);
					allDatas[L"SX"].push_back(sx);
				}
				else
				{
					hother = 0;
				}
				if (m_statment->IsColumnNull(4) != true && hother == 1)//SY
				{
					sy = m_statment->GetValueDouble(4);
					allDatas[L"SY"].push_back(sy);
				}
				else
				{
					hother = 0;
				}
				if (m_statment->IsColumnNull(5) != true && hother == 1)//SZ
				{
					sz = m_statment->GetValueDouble(5);
					allDatas[L"SZ"].push_back(sz);
				}
				else
				{
					hother = 0;
				}
				if (m_statment->IsColumnNull(6) != true && hother == 1)//SXY
				{
					sxy = m_statment->GetValueDouble(6);
					allDatas[L"SXY"].push_back(sxy);
				}
				else
				{
					hother = 0;
				}
				if (m_statment->IsColumnNull(7) != true && hother == 1)//SXZ
				{
					sxz = m_statment->GetValueDouble(7);
					allDatas[L"SXZ"].push_back(sxz);
				}
				else
				{
					hother = 0;
				}
				if (m_statment->IsColumnNull(8) != true && hother == 1)//SYZ
				{
					syz = m_statment->GetValueDouble(8);
					allDatas[L"SYZ"].push_back(syz);
				}
				else
				{
					hother = 0;
				}
				
			}
		}
		m_statment->Finalize();
	}

}
void GetMeshDatas(bvector<bvector<ContourPoint>>& meshpoints, WString typeName, int caseID, int ProjecID, bmap<WString, bvector<double>>& allNineDatas, RotMatrix rotMatrix)
{
	NamedGroupCollectionPtr ngcCutFace;
	NamedGroupFlags ngfCutFace;
	NamedGroupPtr ngCutFace;
	ngcCutFace = NamedGroupCollection::Create(*ACTIVEMODEL);

	bvector<double>   oCaeresults;
	bvector<double>   oCaeresults2;
 
	Bentley::Transform* tMatrix;
	tMatrix = NULL;
	for each (NamedGroupPtr namedGroup in *ngcCutFace)
	{
		if (namedGroup.IsValid())
		{
			WString ngName = namedGroup->GetName();
			if (ngName.find(L"CAECLIP") != WString::npos)
			{
				UInt32 graphicMembers;
				namedGroup->GetMemberCount(&graphicMembers, NULL);
				for (UInt32 i = 0; i < graphicMembers; i++)
				{
					ElementId elemid = namedGroup->GetMember(i)->GetElementId();
					EditElementHandle eeh;
					if (SUCCESS == eeh.FindByID(elemid, ACTIVEMODEL))//得到的每一个mesh面
					{
						if (tMatrix == NULL)
						{
							bvector<int>					pIndices;
							bvector<DPoint3d>				pXYZ;
							bvector<bvector<ContourPoint>>	vecSolidPtAndValTmp;
							bvector<ContourPoint>			vecFacePtAndVal;
							int								iNumIndexPerFace;
							int								iNumFace;
							if (SUCCESS == mdlMesh_getPolyfaceArrays(eeh.GetElementDescrCP(), &pIndices, &pXYZ, &iNumIndexPerFace, &iNumFace))
							{
								//转换矩阵获取
								XAttributeHandlerId handlerMatrixId(XAttrHandleID_Matrix, XAttrHandleID_Matrix);
								XAttributeHandle Matrixh(eeh.GetElementRef(), handlerMatrixId, XAttrID_Matirx);
								if (Matrixh.IsValid())
								{
									tMatrix = (Bentley::Transform*)Matrixh.PeekData();
								}
								else
									continue;
							}
							GetOutDataCaeResult(oCaeresults, oCaeresults2,ProjecID, caseID, typeName, allNineDatas, tMatrix, rotMatrix);
						}
						bvector<ContourPoint>  MeshPoints;
						ClipFace::GetMeshPointsAndValueForOutDatalist(oCaeresults, oCaeresults2, MeshPoints, eeh, typeName, caseID, ProjecID);
						meshpoints.push_back(MeshPoints);
					}
				}

			}
		}
	}
}

void OutValueLists(WCharCP unparsed)
{
	if (ClipFace::IsClipFaceModel())//生成数值图
	{
		DgnPlatform::LevelId  levelId_OutData;

		// 创建或取得CAE模型的显示图层
		if (SUCCESS != mdlLevel_create(&levelId_OutData, OutDataModelRef, L"CLIPOUTDATA", LEVEL_NULL_CODE))
			mdlLevel_getIdFromName(&levelId_OutData, OutDataModelRef, LEVEL_NULL_ID, L"CLIPOUTDATA");

		bvector<DPoint3d> meshminpoints;
		bvector<DPoint3d> meshmaxpoints;
		DPoint3d minpoint;
		DPoint3d maxpoint;
		bvector<MSElementDescrP> outLines;//外轮廓所有线段
		OutColumnData::GetOutLineDsc(outLines, minpoint, maxpoint);
		int ProjectID;
		GetMeshMinMaxPoints(meshminpoints, meshmaxpoints, minpoint, maxpoint, ProjectID);

		/*EditElementHandle eeh;
		DraftingElementSchema::ToElement(eeh, *ICurvePrimitive::CreateLine(DSegment3d::From(minpoint, maxpoint)), NULL, ACTIVEMODEL->Is3d(), *ACTIVEMODEL);
		eeh.AddToModel();*/
	

		bvector<bvector<DPoint3d>> alloutPoints;
		OutLineData       outLine;
		DataListParamas   tempoutParama;
		outLine.EleMinPoint = minpoint;
		outLine.EleMaxPoint = maxpoint;
		//int    ListIndex = 0;
		//tempoutParama.left_dis = 0.067;//画外方框左偏移比例值（以左下角与右上角距离为基础值）
		//tempoutParama.right_dis = 0.045; //画外方框右偏移比例值
		//tempoutParama.top_dis = 0.401;//画外方框上偏移比例值
		//tempoutParama.bottom_dis = 0.221;//画外方框下偏移比例值
		tempoutParama.ListTitle = O_tableTitle/*L"哈吉水电站引水坝段"*/;//数值表名,

		//tempoutParama.TypeName = L"X向正应力";//值类型名
		tempoutParama.CutFaceName = L"截面Y = 9";//断面位置
		tempoutParama.CaseName = O_CaseName;//工况名
		//tempoutParama.UnitName = L"单位:Ma";//单位名
		tempoutParama.row = O_XValueCnt;
		tempoutParama.col = O_YValueCnt;
		tempoutParama.TitFontSize = O_titleFont * UOR_PER_METER;
		tempoutParama.CasFontSize = O_contentFont* UOR_PER_METER;
		tempoutParama.cordFontSize = O_coorFont* UOR_PER_METER;
		tempoutParama.DataFontSize = O_valueFont* UOR_PER_METER;
		tempoutParama.Decimal = O_decimal;
		tempoutParama.isS1 = false;//设置不是输出S1
		int caseID = s_pDCShape->CaseID;
		move_dis = (maxpoint.x - minpoint.x) + 4 * 15 * tempoutParama.DataFontSize;/*(maxpoint.x - minpoint.x) * 6 / 5;*/
		int outValueNum = 0;
		bmap<WString, bvector<double>> allNineDatas;
		GetAllNineDatas(allNineDatas, caseID, ProjectID);
		RotMatrix inMatrix = RotMatrix::FromRowValues(1.0, 0.0, 0.0,
													  0.0, 1.0, 0.0, 
													  0.0, 0.0, 1.0);
 		for (int i = 0; i < outValueTypeint.size(); i++)
		{
			if (outValueTypeint.at(i))
			{
				WString tyPeName = outValueTypeWString.at(i);

				//第一个为画网格图
				if (i!=0)
				{
					//除开UX,UY,UZ,有一个没有值就计算不了
					if (tyPeName != L"UX"&&tyPeName != L"UY"&&tyPeName != L"UZ")
					{
						if (allNineDatas[L"SX"].size() < 1 || allNineDatas[L"SY"].size() < 1 || allNineDatas[L"SZ"].size() < 1
							|| allNineDatas[L"SXY"].size() < 1 || allNineDatas[L"SXZ"].size() < 1 || allNineDatas[L"SYZ"].size() < 1)
						{
							continue;
						}
						else
						{
							if (tyPeName == L"S1")//判断此时输出的是S1
							{
								tempoutParama.isS1 = true;
							}
						}
					}
					else
					{
						if (allNineDatas[tyPeName].size()<1)
						{
							continue;
						}
					}
					
				}
				DPoint3d tempMinPoint = minpoint;
				DPoint3d tempMaxPoint = maxpoint;
				tempMinPoint.x = outValueNum*move_dis + tempMinPoint.x;
				tempMaxPoint.x = outValueNum*move_dis + tempMaxPoint.x;
				if (i == 0)//画网格图框
				{
					tempoutParama.UnitName.clear();
					tempoutParama.TypeName = L"网格图";
					//tempoutParama.UnitName.append(L"");
				}
				else
				{
					tempoutParama.UnitName.clear();
					tempoutParama.UnitName.append(L"单位：");
					WString DanWName;
					if (!IsTypeNameHaveValue(tyPeName, ProjectID, caseID))//如果typeName中没值，此数值图不输出
					{
						continue;
					}
					GetUnitAndTypeNameByeCode(tyPeName, DanWName, tempoutParama.TypeName);
					if (DanWName.find(L"m")!=WString::npos)
					{
						DanWName = L"mm";
					}
					if (DanWName.find(L"Pa") != WString::npos)
					{
						DanWName = L"MPa";
					}
					tempoutParama.UnitName.append(DanWName);
				}
				if (outValueNum - 1 >= 0)//输出数值图
				{
					bvector<bvector<ContourPoint>> meshpoints;
					GetMeshDatas(meshpoints, tyPeName, caseID, ProjectID, allNineDatas, inMatrix);
					CreateFaceOutLine(s_drawtempLine.linePoints, move_dis, outValueNum, levelId_OutData);
					CreateOutDataList(tempMinPoint, tempMaxPoint, outValueNum, tempoutParama, caseID, minpoint, maxpoint,
						meshpoints, meshminpoints, meshmaxpoints, levelId_OutData, outLines);
				}
				else//画网格图时不输出数值图
				{
					OutLineData       outLine;//偏移后的外方框参数
					outLine.EleMinPoint = tempMinPoint;
					outLine.EleMaxPoint = tempMaxPoint;
					//根据切面的最大和最小值点画内方框和Y方向辅助线
					CreateOutFrame(tempoutParama, outValueNum, outLine, minpoint, maxpoint, levelId_OutData);
				}
				tempoutParama.isS1 = false;
				outValueNum++;
			}
		}
	}
}
void CreateFaceOutLine(bvector<DPoint3d>& linePoints, double mdis, int Index, DgnPlatform::LevelId  levelId_OutData)
{
	for (size_t i = 0; i < linePoints.size(); i = i + 2)
	{
		DPoint3d pts[2];
		if (i < linePoints.size() - 1)
		{
			pts[0] = linePoints[i];
			pts[1] = linePoints[i+1];
			pts[0].x = pts[0].x + Index*mdis;
			pts[1].x = pts[1].x + Index*mdis;
			EditElementHandle eeh;
			DraftingElementSchema::ToElement(eeh, *ICurvePrimitive::CreateLine(DSegment3d::From(pts[0], pts[1])), NULL, ACTIVEMODEL->Is3d(), *ACTIVEMODEL);
			ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
			propsSetter->SetLevel(levelId_OutData);
			propsSetter->Apply(eeh);
			eeh.AddToModel();
		}
	}
}
//判断typeName在数据库中是否有值
bool IsTypeNameHaveValue(WString typeName,int ProjectId,int CaseId)
{
	bool reValue = false;
	Db m_db;
	Statement *m_statment;
	WString strSql;
	StatusInt rc;
	rc = OpenDB(m_db);
	if (rc == BE_SQLITE_OK)
	{
		strSql.clear();
		strSql.append(L"SELECT ");
		strSql.append(typeName);
		strSql.append(L" \n");
		strSql.append(L"FROM RESULTS \n");
		strSql.append(L" WHERE CaseId = @CaseId AND ProjectId = @ProjectId");
		strSql.append(L" \n");

		m_statment = new Statement();

		size_t len = strSql.length() + 1;
		CharP cSQL = (CharP)malloc(len*sizeof(char));
		strSql.ConvertToLocaleChars(cSQL);

		rc = m_statment->Prepare(m_db, cSQL);
		m_statment->BindInt(1, CaseId);
		m_statment->BindInt(2, ProjectId);
		if (rc == BE_SQLITE_OK)
		{
			while (m_statment->Step() == BE_SQLITE_ROW)
			{
				reValue = true;
				break;
			}
		}
		m_statment->Finalize();
		m_statment = NULL;
	}
	m_db.CloseDb();
	return reValue;
}

void GetUnitAndTypeNameByeCode(WString CodeName, WString& UnitName, WString& TypeName)
{
	StatusInt rc;
	Db m_db;
	Statement *m_statment = new Statement();

	rc = OpenDB(m_db);
	if (rc == BE_SQLITE_OK)
	{
		AString strSql;
		strSql.append("SELECT Unit,Name FROM RSTTYPE WHERE Code = @Code \n");
		rc = m_statment->Prepare(m_db, strSql.c_str());
		if (rc == BE_SQLITE_OK)
		{
			// 关联查询条件的值
			Utf8String sCodeName;
			BeStringUtilities::WCharToUtf8(sCodeName, CodeName.c_str());
			m_statment->BindUtf8CP(1, sCodeName.c_str(), m_statment->BindMakeCopy::MAKE_COPY_No);

			while (m_statment->Step() == BE_SQLITE_ROW)
			{
				//单位设置
				UnitName.clear();
				UnitName.AppendUtf8(m_statment->GetValueUtf8(0));
				//类型名称
				TypeName.clear();
				TypeName.AppendUtf8(m_statment->GetValueUtf8(1));

				break;
			}
		}
	}
	m_statment->Finalize();
	m_db.CloseDb();
}

void CreateOutDataList(
	DPoint3d move_minPoint,//偏移后切面左下角点
	DPoint3d move_maxPoint,//偏移后切面右上角点
	int    ListIndex,//生成数值表图序号
	DataListParamas& dataparams,
	int caseID, DPoint3d orgminpt, DPoint3d orgmaxpt,
	bvector<bvector<ContourPoint>>& MeshPoints, bvector<DPoint3d>& meshminpts, bvector<DPoint3d>& meshmaxpts
	, DgnPlatform::LevelId  levelId_OutData, bvector<MSElementDescrP>& outLines
	)
{
	//minPoint和maxPoint为偏移过的最小最大坐标点
	bvector<bvector<DPoint3d>> alloutPoints;
	OutLineData       outLine;//偏移后的外方框参数
	double PerHeight;
	outLine.EleMinPoint = move_minPoint;
	outLine.EleMaxPoint = move_maxPoint;
	double EleWidth = mdlVec_distance(&outLine.EleMinPoint, &outLine.EleMaxPoint);
	//根据切面的最大和最小值点画内方框和Y方向辅助线
	CreatePListAndGetAPoints(move_minPoint, move_maxPoint, dataparams.col, dataparams.row, alloutPoints, ListIndex, PerHeight, levelId_OutData, outLines);

	CreateOutFrame(dataparams, ListIndex, outLine, orgminpt, orgmaxpt,levelId_OutData);

	CaculateAndDisplayValue(alloutPoints, ListIndex - 1, dataparams, caseID,PerHeight,orgminpt,orgmaxpt,
		MeshPoints, meshminpts, meshmaxpts, levelId_OutData);
}

void CreateOutFrame(DataListParamas dataparams, int ListIndex, OutLineData& outLine, DPoint3d orgminpt, DPoint3d orgmaxpt, DgnPlatform::LevelId  levelId_OutData)
{
	//创建外轮廓方框并标注X和Y方向坐标值（对应切面的坐标）
	CreateOutLine(outLine.EleMinPoint, outLine.EleMaxPoint, dataparams, outLine, ListIndex, orgminpt, orgmaxpt, levelId_OutData);

	{//生成相关标题和应力类型名称
		//WString tTitle = L"哈吉水电站引水坝段";
		DPoint3d tTPos;
		tTPos.x = outLine.OutLineMinPoint.x + abs(outLine.OutLineMaxPoint.x - outLine.OutLineMinPoint.x) * 0.4;
		tTPos.y = outLine.OutLineMaxPoint.y - 3 * dataparams.CasFontSize;
		tTPos.z = outLine.OutLineMaxPoint.z;

		ClipFace::CreateText(tTPos, dataparams.TitFontSize, dataparams.TitFontSize, dataparams.ListTitle,levelId_OutData,OutDataModelRef);

		//结果类型的位置设定
		tTPos.x = outLine.EleMaxPoint.x - 12 * dataparams.CasFontSize;
		ClipFace::CreateText(tTPos, dataparams.TitFontSize, dataparams.TitFontSize, dataparams.TypeName, levelId_OutData, OutDataModelRef);
	}
		{//生成工况名和断面名以及单位
			//WString tTitle = L"工况一";
			DPoint3d tTPos;
			tTPos.x = outLine.OutLineMinPoint.x + abs(outLine.OutLineMaxPoint.x - outLine.OutLineMinPoint.x) * 0.4;
			tTPos.y = outLine.OutLineMaxPoint.y - 5 * dataparams.CasFontSize;
			tTPos.z = outLine.OutLineMaxPoint.z;
			ClipFace::CreateText(tTPos, dataparams.CasFontSize, dataparams.CasFontSize, dataparams.CaseName, levelId_OutData, OutDataModelRef);

			//tTitle = L"截面Y = 9";
			//tTPos.x = tTPos.x + fWidth * 50;
			//ClipFace::CreateText(tTPos, fWidth, dataparams.CasFontSize, dataparams.CutFaceName, levelId_OutData, OutDataModelRef);

			//tTitle = L"单位:Ma";
			tTPos.x = outLine.EleMaxPoint.x - 5 * dataparams.CasFontSize;
			ClipFace::CreateText(tTPos, dataparams.CasFontSize, dataparams.CasFontSize, dataparams.UnitName, levelId_OutData, OutDataModelRef);
		}
}

void CreatePListAndGetAPoints(DPoint3d minPos, DPoint3d maxPos, int widthNum, int heightNum, bvector<bvector<DPoint3d>>& alloutPoints, int Index, double& PerHeight, DgnPlatform::LevelId  levelId_OutData, bvector<MSElementDescrP>& outLines)
{

	double width = maxPos.x - minPos.x;
	double height = maxPos.y - minPos.y;
	DPoint3d top_leftP, top_rightP;
	DPoint3d bottom_leftP, bottom_rightP;

	//画内方框，坐标是偏移后的坐标
	top_leftP.x = minPos.x;
	bottom_leftP.x = top_leftP.x;
	top_rightP.x = maxPos.x;
	bottom_rightP.x = top_rightP.x;

	top_leftP.y = maxPos.y;
	top_rightP.y = top_leftP.y;
	bottom_leftP.y = minPos.y;
	bottom_rightP.y = bottom_leftP.y;

	top_leftP.z = top_rightP.z = bottom_leftP.z = bottom_rightP.z = maxPos.z;

	bvector<DPoint3d>  OutLineString;
	OutLineString.push_back(top_leftP);
	OutLineString.push_back(top_rightP);
	OutLineString.push_back(bottom_rightP);
	OutLineString.push_back(bottom_leftP);
	OutLineString.push_back(top_leftP);

	EditElementHandle eeh;
	DraftingElementSchema::ToElement(eeh, *ICurvePrimitive::CreateLineString(OutLineString), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
	ElementPropertyUtils::ApplyActiveSettings(eeh);
	ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
	propsSetter->SetLevel(levelId_OutData);
	propsSetter->Apply(eeh);
	eeh.AddToModel();


	PerHeight = height / heightNum;

	//{//创建y方向辅助直线

	//	for (int i = 0; i < heightNum; i++)
	//	{
	//		DPoint3d st, et;
	//		st.x = top_leftP.x;
	//		st.y = bottom_leftP.y + PerHeight*i;

	//		et.y = st.y;
	//		et.x = st.x + width;

	//		st.z = et.z = top_leftP.z;
	//		EditElementHandle tempLine;
	//		DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(st, et)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
	//		ElementPropertyUtils::ApplyActiveSettings(tempLine);
	//		ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
	//		propsSetter->SetLevel(levelId_OutData);
	//		propsSetter->Apply(tempLine);
	//		tempLine.AddToModel();
	//	}
	//}

	//计算划分后的坐标点（要对应切面上坐标）
	double PerWidth = width / widthNum;
	for (int i = 0; i <= heightNum; i++)
	{
		bvector<DPoint3d> tempWidthPoint;
		for (int j = 0; j <= widthNum; j++)
		{
			DPoint3d ptTmpLineEnd;
			//由于传进来的坐标是偏移过的坐标，需要将坐标偏移回原来位置，偏移量与第几个方框（index）有关
			ptTmpLineEnd.x = bottom_leftP.x + j*PerWidth - Index*move_dis/*(maxPos.x - minPos.x) * 6 / 5*/;
			ptTmpLineEnd.y = bottom_leftP.y + i*PerHeight;
			ptTmpLineEnd.z = bottom_leftP.z;

			//DPoint3d samePoint = bottom_leftP;
			if (j > 0) // 求取与外轮廓上的交点坐标并添加
			{
				DPoint3d ptTmpLineStart;
				ptTmpLineStart.x = bottom_leftP.x + (j - 1)*PerWidth - Index*move_dis;
				ptTmpLineStart.y = bottom_leftP.y + i*PerHeight;
				ptTmpLineStart.z = bottom_leftP.z;
				for (int i = 0; i < outLines.size(); i++)
				{
					MSElementDescrP tempDes = outLines.at(i);
					DPoint3d start, end, intersertPoint;
					mdlElmdscr_extractEndPoints(&start, NULL, &end, NULL, tempDes, ACTIVEMODEL);
					start.z = end.z = bottom_leftP.z;
					intersertPoint = GetTwoLineIntersect(start, end, ptTmpLineStart, ptTmpLineEnd);
					if (MsdiMsCaeSiUtility::PtIsOnline(intersertPoint, start, end) && 
						MsdiMsCaeSiUtility::PtIsOnline(intersertPoint, ptTmpLineStart, ptTmpLineEnd))
					{
						if (!(intersertPoint.AlmostEqual(ptTmpLineStart) || intersertPoint.AlmostEqual(ptTmpLineEnd)))
						{
							tempWidthPoint.push_back(intersertPoint);
						}
					}
				}
			}
			tempWidthPoint.push_back(ptTmpLineEnd);
		}
		
		alloutPoints.push_back(tempWidthPoint);
	}
}

void CaculateAndDisplayValue(bvector<bvector<DPoint3d>>&alloutPoints, int index, DataListParamas& dataparams
	, int caseID, double PerHeight, DPoint3d orgminpt, DPoint3d orgmaxpt,
	bvector<bvector<ContourPoint>>& MeshPoints,bvector<DPoint3d>& meshminpts,bvector<DPoint3d>& meshmaxpts, 
	DgnPlatform::LevelId  levelId_OutData)
{
	bvector<bvector<ContourPoint>>  outPointAndValues;
		for (int i = 0; i < alloutPoints.size(); i++)
		{
			bvector<DPoint3d> widthPoint = alloutPoints.at(i);
			bvector<ContourPoint> widthContour;
			for (size_t j = 0; j < widthPoint.size(); j++)
			{
				ContourPoint tempPoint;
				tempPoint.dPt = widthPoint.at(j);

				for (UInt32 k = 0; k < MeshPoints.size(); k++)
				{
						DPoint3d ptmin;
						DPoint3d ptmax;
						ptmin = meshminpts.at(k);
						ptmax = meshmaxpts.at(k);
						if (PtInRange(tempPoint.dPt, ptmin, ptmax))//判断点是否在range中
						{
							bvector<ContourPoint>  tMeshPoints;
							tMeshPoints = MeshPoints.at(k);
							if (tMeshPoints.size() == 7)//六边形
							{
								if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[0], &tMeshPoints[1]))//判断点是否在第一条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[1], &tMeshPoints[2]))//判断点是否在第二条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[2], &tMeshPoints[3]))//判断点是否在第三条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[3], &tMeshPoints[4]))//判断点是否在第四条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[4], &tMeshPoints[5]))//判断点是否在第五条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[5], &tMeshPoints[6]))//判断点是否在第六条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else
								{
									if (PtInPolygon(tempPoint.dPt, tMeshPoints, tMeshPoints.size()))//点在端点组成的区域内
									{
										tempPoint.dVal = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tMeshPoints, tempPoint.dPt, false);
										if (dataparams.isS1 == true)
										{
											bvector<ContourPoint> tempPoints;
											for (int i = 0; i < tMeshPoints.size(); i++)
											{
												ContourPoint tempPt;
												tempPt.dPt = tMeshPoints.at(i).dPt;
												tempPt.dVal = tMeshPoints.at(i).dVal2;
												tempPoints.push_back(tempPt);
											}
											tempPoint.dVal2 = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tempPoints, tempPoint.dPt, true);
											bvector<ContourPoint>().swap(tempPoints);
										}
										widthContour.push_back(tempPoint);
										break;
									}
								}
							}
							else if (tMeshPoints.size() == 6)//五边形
							{
								if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[0], &tMeshPoints[1]))//判断点是否在第一条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[1], &tMeshPoints[2]))//判断点是否在第二条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[2], &tMeshPoints[3]))//判断点是否在第三条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[3], &tMeshPoints[4]))//判断点是否在第四条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[4], &tMeshPoints[5]))//判断点是否在第五条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else
								{
									if (PtInPolygon(tempPoint.dPt, tMeshPoints, tMeshPoints.size()))//点在端点组成的区域内
									{
										tempPoint.dVal = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tMeshPoints, tempPoint.dPt, false);
										if (dataparams.isS1 == true)
										{
											bvector<ContourPoint> tempPoints;
											for (int i = 0; i < tMeshPoints.size(); i++)
											{
												ContourPoint tempPt;
												tempPt.dPt = tMeshPoints.at(i).dPt;
												tempPt.dVal = tMeshPoints.at(i).dVal2;
												tempPoints.push_back(tempPt);
											}
											tempPoint.dVal2 = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tempPoints, tempPoint.dPt, true);
											bvector<ContourPoint>().swap(tempPoints);
										}
										widthContour.push_back(tempPoint);
										break;
									}
								}
							}
							else if (tMeshPoints.size() == 5)//四边形
							{
								if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[0], &tMeshPoints[1]))//判断点是否在第一条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[1], &tMeshPoints[2]))//判断点是否在第二条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[2], &tMeshPoints[3]))//判断点是否在第三条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[3], &tMeshPoints[4]))//判断点是否在第四条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else
								{
									if (PtInPolygon(tempPoint.dPt, tMeshPoints, tMeshPoints.size()))//点在端点组成的区域内
									{
										tempPoint.dVal = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tMeshPoints, tempPoint.dPt);
										if (dataparams.isS1 == true)
										{
											bvector<ContourPoint> tempPoints;
											for (int i = 0; i < tMeshPoints.size();i++)
											{
												ContourPoint tempPt;
												tempPt.dPt = tMeshPoints.at(i).dPt;
												tempPt.dVal = tMeshPoints.at(i).dVal2;
												tempPoints.push_back(tempPt);
											}
											tempPoint.dVal2 = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tempPoints, tempPoint.dPt);
											bvector<ContourPoint>().swap(tempPoints);
										}
										widthContour.push_back(tempPoint);
										break;
									}
								}
							}
							else if (tMeshPoints.size() == 4)//三边形
							{
								if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[0], &tMeshPoints[1]))//判断点是否在第一条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[1], &tMeshPoints[2]))//判断点是否在第二条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else if (IsInSameLineAndSetSingleValue(&tempPoint, &tMeshPoints[2], &tMeshPoints[3]))//判断点是否在第三条线上
								{
									widthContour.push_back(tempPoint);
									break;
								}
								else
								{
									if (PtInPolygon(tempPoint.dPt, tMeshPoints, tMeshPoints.size()))//点在端点组成的区域内
									{
										tempPoint.dVal = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tMeshPoints, tempPoint.dPt);
										if (dataparams.isS1 == true)
										{
											bvector<ContourPoint> tempPoints;
											for (int i = 0; i < tMeshPoints.size(); i++)
											{
												ContourPoint tempPt;
												tempPt.dPt = tMeshPoints.at(i).dPt;
												tempPt.dVal = tMeshPoints.at(i).dVal2;
												tempPoints.push_back(tempPt);
											}
											tempPoint.dVal2 = MsdiMsCaeSiUtility::UseBilinear_interpolationGetVlue(tempPoints, tempPoint.dPt);
											bvector<ContourPoint>().swap(tempPoints);
										}
										widthContour.push_back(tempPoint);
										break;
									}
								}
							}
					}
				}

			}
			outPointAndValues.push_back(widthContour);
		}
		//求得Value最大值
		double maxValue = 0;
		double minValue = 0;
		for (size_t j = 0; j < outPointAndValues.size(); j++)
		{
			bvector<ContourPoint> widthContour = outPointAndValues.at(j);
			for (size_t i = 0; i < widthContour.size(); i++)
			{
				if (maxValue < widthContour.at(i).dVal)
				{
					maxValue = widthContour.at(i).dVal;
				}
				if (minValue > widthContour.at(i).dVal)
				{
					minValue = widthContour.at(i).dVal;
				}
			}
		}
		WString dec;
		dec.Sprintf(L"%%0.%dg", dataparams.Decimal);
		//画outPointAndValues；
		if (dataparams.isS1==true)//次主应力输出
		{
			for (size_t j = 0; j < outPointAndValues.size(); j++)
			{
				bvector<ContourPoint> widthContour = outPointAndValues.at(j);
				if (widthContour.size() < 2)
				{
					continue;
				}
				for (size_t i = 0; i < widthContour.size(); i++)
				{
					DPoint3d st = widthContour.at(i).dPt;
					double val1 = widthContour.at(i).dVal;
					double val2 = widthContour.at(i).dVal2;
					if (val1<val2)
					{
						double tempd = val1;
						val1 = val2;
						val2 = tempd;
					}
					DPoint3d xlinestr, xlinend;
					xlinestr = st;
					xlinend = st;
					xlinestr.x = st.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/ - 1 * UOR_PER_METER;
					xlinend.x = st.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/ + 1 * UOR_PER_METER;
					EditElementHandle tLine;
					DraftingElementSchema::ToElement(tLine, *ICurvePrimitive::CreateLine(DSegment3d::From(xlinestr, xlinend)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
					ElementPropertyUtils::ApplyActiveSettings(tLine);
					ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
					propsSetter->SetLevel(levelId_OutData);
					propsSetter->Apply(tLine);
					tLine.AddToModel();
					
					DPoint3d ylinestr, ylinend;
					ylinestr = st;
					ylinend = st;
					ylinestr.x = st.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/ ;
					ylinend.x = st.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
					ylinestr.y = st.y - 0.500 * UOR_PER_METER;
					ylinend.y = st.y + 0.500 * UOR_PER_METER;
					EditElementHandle tempLine;
					DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(ylinestr, ylinend)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
					ElementPropertyUtils::ApplyActiveSettings(tempLine);
					propsSetter->Apply(tempLine);
					tempLine.AddToModel();

					{//生成X1应力数值
						WChar buffer[20];
						if (dataparams.UnitName.find(L"mm") != WString::npos)
						{
							unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
							//_swprintf(buffer, dec.GetWCharCP(), val1 * 1000);
							_swprintf(buffer, dec.GetWCharCP(), val1);
							_set_output_format(old_exponent_format);
						}
						if (dataparams.UnitName.find(L"MPa") != WString::npos)
						{
							unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
							//_swprintf(buffer, dec.GetWCharCP(), val1 / 1000000);
							_swprintf(buffer, dec.GetWCharCP(), val1 );
							_set_output_format(old_exponent_format);
						}
						ClipFace::CreateText(ylinestr, dataparams.DataFontSize, dataparams.DataFontSize, buffer, levelId_OutData, OutDataModelRef);
					}
					{//生成X2应力数值
						WChar buffer[20];
						if (dataparams.UnitName.find(L"mm") != WString::npos)
						{
							unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
							//_swprintf(buffer, dec.GetWCharCP(), val2 * 1000);
							_swprintf(buffer, dec.GetWCharCP(), val2);
							_set_output_format(old_exponent_format);
						}
						if (dataparams.UnitName.find(L"MPa") != WString::npos)
						{
							unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
							//_swprintf(buffer, dec.GetWCharCP(), val2 / 1000000);
							_swprintf(buffer, dec.GetWCharCP(), val2 );
							_set_output_format(old_exponent_format);
						}
						ClipFace::CreateText(ylinend, dataparams.DataFontSize, dataparams.DataFontSize, buffer, levelId_OutData, OutDataModelRef);
					}

				}
			}
			dataparams.isS1 = false;
		}
		else
		{
			for (size_t j = 0; j < outPointAndValues.size(); j++)
			{
				bvector<ContourPoint> widthContour = outPointAndValues.at(j);
				if (widthContour.size() < 2)
				{
					continue;
				}
				double twidth = mdlVec_distance(&widthContour.at(0).dPt, &widthContour.at(1).dPt);
				for (size_t i = 0; i < widthContour.size(); i++)
				{
					if (i + 1 < widthContour.size())//不是容器最后一个点
					{
						//从左到右为-1，或者从右到左为1
						int leftorright;
						DPoint3d st = widthContour.at(i).dPt;
						DPoint3d stNext = widthContour.at(i + 1).dPt;
						if (stNext.AlmostEqual(st))
							continue;

						DPoint3d stTempNext;
						stTempNext.x = (st.x + stNext.x) / 2;
						stTempNext.y = (st.y + stNext.y) / 2;
						stTempNext.z = st.z;
						bool paintLine = false;
						for (UInt32 k = 0; k < MeshPoints.size(); k++) // 循环遍历所有MESH面，若二点的中点在某一面上，返回TRUE,否则不画线
						{
							bvector<ContourPoint>  tMeshPoints;
							tMeshPoints = MeshPoints.at(k);
							if (MsdiMsCaeSiUtility::PointInPolygon(stTempNext, tMeshPoints))
							{
								paintLine = true;
								break;
							}
						}

						if (stNext.x > st.x)//从左往右
						{
							leftorright = -1;
						}
						else
						{
							leftorright = 1;
						}

						DPoint3d stlinestr, stlinend;
						stlinestr = st;
						stlinend = stNext;
						stlinestr.x = stlinestr.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
						stlinend.x = stlinend.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
						double tempError = mdlVec_distance(&stlinestr, &stlinend) - twidth;
						ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
						EditElementHandle tLine;
						DraftingElementSchema::ToElement(tLine, *ICurvePrimitive::CreateLine(DSegment3d::From(stlinestr, stlinend)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
						ElementPropertyUtils::ApplyActiveSettings(tLine);
						propsSetter->SetLevel(levelId_OutData);
						propsSetter->Apply(tLine);
						if (paintLine)
						{
							tLine.AddToModel();
						}

						DPoint3d vec;
						vec.x = stNext.x - st.x;
						vec.y = stNext.y - st.y;
						vec.z = stNext.z - st.z;

						DPoint3d normalvec;
						normalvec.x = leftorright * vec.y;
						normalvec.y = -1 * leftorright*vec.x;
						normalvec.z = vec.z;
						normalvec.Normalize();

						st.x = st.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
						DPoint3d et = st;
						if (maxValue != minValue)
						{
							et.x = et.x + ((widthContour.at(i).dVal) / (maxValue - minValue)*PerHeight)*normalvec.x;
							et.y = et.y + ((widthContour.at(i).dVal) / (maxValue - minValue)*PerHeight)*normalvec.y;
						}
						EditElementHandle tempLine;
						DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(st, et)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
						ElementPropertyUtils::ApplyActiveSettings(tempLine);
						propsSetter->Apply(tempLine);
						tempLine.AddToModel();

						DPoint3d stnext = widthContour.at(i + 1).dPt;
						stnext.x = stnext.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
						DPoint3d etnext = stnext;
						if (maxValue != minValue)
						{
							//etnext.y = etnext.y + ((widthContour.at(i + 1).dVal) / (maxValue - minValue)*PerHeight);
							etnext.x = etnext.x + ((widthContour.at(i + 1).dVal) / (maxValue - minValue)*PerHeight)*normalvec.x;
							etnext.y = etnext.y + ((widthContour.at(i + 1).dVal) / (maxValue - minValue)*PerHeight)*normalvec.y;
						}
						EditElementHandle ContectLine;
						DraftingElementSchema::ToElement(ContectLine, *ICurvePrimitive::CreateLine(DSegment3d::From(et, etnext)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
						ElementPropertyUtils::ApplyActiveSettings(ContectLine);
						//ContectLine.AddToModel();
						propsSetter->SetLinestyle(3, NULL);
						propsSetter->Apply(ContectLine);
						if (paintLine)
						{
							ContectLine.AddToModel();
						}

						{//生成应力数值
							WChar buffer[20];
							if (dataparams.UnitName.find(L"mm") != WString::npos)
							{
								unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
								//_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal * 1000);
								_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal);
								_set_output_format(old_exponent_format);
							}
							if (dataparams.UnitName.find(L"MPa") != WString::npos)
							{
								unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
								//_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal / 1000000);
								_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal );
								_set_output_format(old_exponent_format);
							}
							ClipFace::CreateText(et, dataparams.DataFontSize, dataparams.DataFontSize, buffer, levelId_OutData, OutDataModelRef);
						}
					}
					else//容器最后一个
					{

						DPoint3d st = widthContour.at(i - 1).dPt;
						DPoint3d stNext = widthContour.at(i).dPt;
						DPoint3d vec;
						//从左到右为-1，或者从右到左为1
						int leftorright;
						if (stNext.x > st.x)//从左往右
						{
							leftorright = -1;
						}
						else
						{
							leftorright = 1;
						}
						vec.x = stNext.x - st.x;
						vec.y = stNext.y - st.y;
						vec.z = stNext.z - st.z;

						DPoint3d normalvec;
						normalvec.x = leftorright * vec.y;
						normalvec.y = -1 * leftorright*vec.x;
						normalvec.z = vec.z;
						normalvec.Normalize();

						stNext.x = stNext.x + (index + 1)*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;
						DPoint3d et = stNext;
						if (maxValue != minValue)
						{
							et.x = et.x + ((widthContour.at(i).dVal) / (maxValue - minValue)*PerHeight)*normalvec.x;
							et.y = et.y + ((widthContour.at(i).dVal) / (maxValue - minValue)*PerHeight)*normalvec.y;
						}
						EditElementHandle tempLine;
						DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(stNext, et)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
						ElementPropertyUtils::ApplyActiveSettings(tempLine);
						ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
						propsSetter->SetLevel(levelId_OutData);
						propsSetter->Apply(tempLine);
						tempLine.AddToModel();

						{//生成应力数值
							WChar buffer[20];
							if (dataparams.UnitName.find(L"mm") != WString::npos)
							{
								unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
								//_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal * 1000);
								_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal);
								_set_output_format(old_exponent_format);
							}
							if (dataparams.UnitName.find(L"MPa") != WString::npos)
							{
								unsigned int  old_exponent_format = _set_output_format(_TWO_DIGIT_EXPONENT);
								//_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal / 1000000);
								_swprintf(buffer, dec.GetWCharCP(), widthContour.at(i).dVal );
								_set_output_format(old_exponent_format);
							}
							ClipFace::CreateText(et, dataparams.DataFontSize, dataparams.DataFontSize, buffer, levelId_OutData, OutDataModelRef);
						}
					}
				}
			}
		}
}

void CreateOutLine(DPoint3d minPos, DPoint3d maxPos, DataListParamas datalistpraramas, 
	OutLineData&  outLine, int Index, DPoint3d orgminpt, DPoint3d orgmaxpt,DgnPlatform::LevelId levelId_OutData)
{

	double left_dis = datalistpraramas.left_dis;
	double right_dis = datalistpraramas.right_dis;
	double top_dis = datalistpraramas.top_dis;
	double bottom_dis = datalistpraramas.bottom_dis;
	
	int YNum = O_XSpaceCnt;//x坐标系等分数
	int XNum = O_YSpaceCnt;//y坐标系等分数


	DPoint3d top_leftP, top_rightP;
	DPoint3d bottom_leftP, bottom_rightP;

	top_leftP.x = minPos.x - 15 * datalistpraramas.DataFontSize;
	bottom_leftP.x = top_leftP.x;
	top_rightP.x = maxPos.x + 15 * datalistpraramas.DataFontSize;
	bottom_rightP.x = top_rightP.x;

	top_leftP.y = maxPos.y + 30 * datalistpraramas.DataFontSize; // 15->30
	top_rightP.y = top_leftP.y; 
	bottom_leftP.y = minPos.y - 12 * datalistpraramas.DataFontSize;
	bottom_rightP.y = bottom_leftP.y;

	top_leftP.z = top_rightP.z = bottom_leftP.z = bottom_rightP.z = maxPos.z;

	bvector<DPoint3d>  OutLineString;
	OutLineString.push_back(top_leftP);
	OutLineString.push_back(top_rightP);
	OutLineString.push_back(bottom_rightP);
	OutLineString.push_back(bottom_leftP);
	OutLineString.push_back(top_leftP);

	outLine.OutLineMinPoint = bottom_leftP;
	outLine.OutLineMaxPoint = top_rightP;

	EditElementHandle eeh;
	DraftingElementSchema::ToElement(eeh, *ICurvePrimitive::CreateLineString(OutLineString), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
	ElementPropertyUtils::ApplyActiveSettings(eeh);
	ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
	propsSetter->SetLevel(levelId_OutData);
	propsSetter->Apply(eeh);
	eeh.AddToModel();

	double PerWidth = (outLine.OutLineMaxPoint.x - outLine.OutLineMinPoint.x) / XNum;
	
	double PerHeight = (outLine.OutLineMaxPoint.y - outLine.OutLineMinPoint.y) / YNum;
	{//创建Y坐标系

		for (int i = 1; i < YNum; i++)
		{
			DPoint3d st, et;
			st.x = top_leftP.x;
			st.y = bottom_leftP.y + PerHeight*i;

			et.y = st.y;
			et.x = st.x + 0.5*datalistpraramas.DataFontSize;

			st.z = et.z = top_leftP.z;
			EditElementHandle tempLine;
			DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(st, et)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
			ElementPropertyUtils::ApplyActiveSettings(tempLine);
			ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
			propsSetter->SetLevel(levelId_OutData);
			propsSetter->Apply(tempLine);
			tempLine.AddToModel();
			{//生成相关标题和应力类型名称
				WChar buffer[20];
				_swprintf(buffer, L"%0.2f", (st.y - orgminpt.y) / UOR_PER_METER);
				DPoint3d tTPos;

				tTPos = st;
				tTPos.x = tTPos.x + 5 * datalistpraramas.DataFontSize;
				ClipFace::CreateText(tTPos, datalistpraramas.cordFontSize, datalistpraramas.cordFontSize, buffer, levelId_OutData, OutDataModelRef,fc_pi/2);
			}

		}

	}

	{//创建X坐标系

		for (int i = 1; i < XNum; i++)
		{
			DPoint3d st, et;
			st.y = bottom_leftP.y;
			st.x = bottom_leftP.x + PerWidth*i;

			et.x = st.x;
			et.y = st.y + 0.5*datalistpraramas.DataFontSize;

			st.z = et.z = top_leftP.z;
			EditElementHandle tempLine;
			DraftingElementSchema::ToElement(tempLine, *ICurvePrimitive::CreateLine(DSegment3d::From(st, et)), NULL, OutDataModelRef->Is3d(), *OutDataModelRef);
			ElementPropertyUtils::ApplyActiveSettings(tempLine);
			ElementPropertiesSetterPtr propsSetter = ElementPropertiesSetter::Create();
			propsSetter->SetLevel(levelId_OutData);
			propsSetter->Apply(tempLine);
			tempLine.AddToModel();

			{//生成相关标题和应力类型名称
				WChar buffer[20];
				double tempX = st.x - Index*move_dis/*(orgmaxpt.x - orgminpt.x) * 6 / 5*/;//x数值偏移到最开始计算位置
				_swprintf(buffer, L"%0.2f", (tempX - orgminpt.x) / UOR_PER_METER);
				DPoint3d tTPos;
				tTPos = st;
				tTPos.y = tTPos.y + 2 * datalistpraramas.DataFontSize;
				ClipFace::CreateText(tTPos, datalistpraramas.cordFontSize, datalistpraramas.cordFontSize, buffer, levelId_OutData, OutDataModelRef);
			}
		}

	}

}

//// 已知点共线，判断点p在线段(str,end)范围内
//bool PtInLineRange2(DPoint3d p, DPoint3d str, DPoint3d end) 
//{
//	DVec3d temp_vec1 = DVec3d::FromStartEnd(str, p);
//	DVec3d temp_vec2 = DVec3d::FromStartEnd(end, p);
//	double tvalue = temp_vec1.DotProduct(temp_vec2);
//	if (tvalue < 0)
//		return true;
//
//	return false;
//}

bool PtInRange(DPoint3d p, DPoint3d ptmin, DPoint3d ptmax)
{
	bool IsInrange = FALSE;
	if (p.y<ptmin.y || p.y>ptmax.y || p.x<ptmin.x || p.x>ptmax.x)//判断实体是否在切线范围内
	{
		IsInrange = FALSE;
	}
	else
	{
		IsInrange = TRUE;
	}
	return IsInrange;
}

// 判断是否共线并计算中间点value值
bool IsInSameLineAndSetSingleValue
(
ContourPoint* mid_Point,
ContourPoint* StartCPt,
ContourPoint* EndCPt
)
{
	bool isinLine = false;
	//DVec3d vec1 = DVec3d::FromStartEndNormalize(StartCPt->dPt, mid_Point->dPt);
	//DVec3d vec2 = DVec3d::FromStartEndNormalize(mid_Point->dPt, EndCPt->dPt);
	//double theDot = 0;
	//theDot = vec1.DotProduct(vec2);
	//if (long(theDot - 0.1) == 1 || long(theDot + 0.1) == 1)
	if (MsdiMsCaeSiUtility::PtIsOnline(mid_Point->dPt, StartCPt->dPt, EndCPt->dPt))
	{
		double value_dis = mdlVec_distance(&StartCPt->dPt, &EndCPt->dPt) + 0.0000001;
		double value_ux = EndCPt->dVectorPt.x - StartCPt->dVectorPt.x;
		double value_uy = EndCPt->dVectorPt.y - StartCPt->dVectorPt.y;
		double value_uz = EndCPt->dVectorPt.z - StartCPt->dVectorPt.z;
		double mid_dis = mdlVec_distance(&StartCPt->dPt, &mid_Point->dPt);

		double value_val = EndCPt->dVal - StartCPt->dVal;
		mid_Point->dVal = StartCPt->dVal + (mid_dis / value_dis)*value_val;
		mid_Point->dVectorPt.x = StartCPt->dVectorPt.x + (mid_dis / value_dis)*value_ux;
		mid_Point->dVectorPt.y = StartCPt->dVectorPt.y + (mid_dis / value_dis)*value_uy;
		mid_Point->dVectorPt.z = StartCPt->dVectorPt.z + (mid_dis / value_dis)*value_uz;
		double value_val2 = EndCPt->dVal2 - StartCPt->dVal2;
		mid_Point->dVal2 = StartCPt->dVal2 + (mid_dis / value_dis)*value_val2;
		isinLine = true;
	}
	return isinLine;
}

// 判断点是否在多边形内
bool PtInPolygon(DPoint3d p, bvector<ContourPoint>& ptPolygon, size_t nCount) 
{
	//// 交点个数   水平/垂直交叉点数判别法
	//int nCross = 0;
	//for (int i = 0; i < nCount - 1; i++)
	//{
	//	DPoint3d p1 = ptPolygon.at(i).dPt;
	//	DPoint3d p2 = ptPolygon.at((i + 1)).dPt;// 最后一个点与第一个点连线  
	//	if (p1.y == p2.y)
	//		continue;
	//	if (p.y < min(p1.y, p2.y))
	//		continue;
	//	if (p.y >= max(p1.y, p2.y))
	//		continue;
	//	// 求交点的x坐标  
	//	double x = (double)(p.y - p1.y) * (double)(p2.x - p1.x) / (double)(p2.y - p1.y + 0.0000001) + p1.x;
	//	// 只统计p1p2与p向右射线的交点  
	//	if (x > p.x)
	//	{
	//		nCross++;
	//	}
	//}
	//// 交点为偶数，点在多边形之外  
	//return (nCross % 2 == 1);

	// 角度和判别法
	double faseangle = 0;
	for (int i = 0; i < nCount - 1; i++)
	{
		DVec3d vec1, vec2;
		vec1 = DVec3d::FromStartEndNormalize(p, ptPolygon.at(i).dPt);
		vec2 = DVec3d::FromStartEndNormalize(p, ptPolygon.at(i + 1).dPt);
		vec1.Normalize();
		vec2.Normalize();
		double theDot = 0;
		theDot = vec1.DotProduct(vec2);
		faseangle += Angle::FromRadians(Angle::Acos(theDot)).Degrees();
	}
	if (faseangle>359 && faseangle < 361)
	{
		return TRUE;
	}
	return FALSE;
}

